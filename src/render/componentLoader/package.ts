import { SetSizeAndPositionChildren } from "../presentation/SetSizeAndPositionChildren"
import { ControlType, PropertyControls, verifyPropertyControls } from "../types/PropertyControls"

import {
    ComponentDefinition,
    ComponentMap,
    ComponentType,
    PackageIdentifier,
    createErrorDefinition,
} from "./definition"
import { findMasters } from "./masters"
import { LazyMap, warn } from "./utils"

export const localPackageFallbackIdentifier = "|local|" // Contains characters that do not exist in normal names

/**
 * Every Framer-generated package will have an index module
 * that is expected to export some special values.
 */
export type FramerIndexModule = {
    exports: FramerModuleExports
}

/**
 * The expected exported object from the index modules generated by Framer.
 */
export type FramerModuleExports = {
    __framer__?: FramerMetadata
}

// TODO: Share this type with Server.
type ComponentInfo = {
    name: string
    children: boolean
    type: ComponentType
}

/** Information representing the context of one or more components. */
type ComponentsContext = {
    packageInfo: PackageInfo

    file?: string
    identifierPrefix?: string
}

type FramerMetadata = {
    packageJson: {
        name?: string // Can be undefined for the local package.
        framer?: {
            components?: ComponentInfo[]
            displayName?: string
        }
        design?: any
    }
    dependencies?: LazyMap<FramerModuleExports>
    sourceModules?: LazyMap<SourceModuleExports>
}

type PackageInfo = {
    depth: number
    displayName: string
    /** The object exported from the index module of this package. */
    exportsObject: FramerModuleExports
    name: string

    /**
     * Map of functions that will import the associated package when called.
     * Key is the name of another package that is a dependency of this package.
     */
    dependencies: LazyMap<FramerModuleExports>
    /**
     * Map of functions that will import the associated module when called.
     * Key is a filename relative to the "code" directory of the package.
     */
    sourceModules: LazyMap<SourceModuleExports>

    componentsJson?: any
    designJson?: any
}

type PackageMap = {
    [name: string]: PackageInfo
}

type SourceModuleExports = {
    __info__?: ComponentInfo[]
    error?: any
}

export function collectComponents(packageInfo: PackageInfo): ComponentMap {
    const components: ComponentMap = {}

    const { componentsJson, depth, designJson, exportsObject, sourceModules } = packageInfo

    // Pull in code components defined in the package.
    const files = Object.keys(sourceModules)
    if (files.length > 0) {
        for (const file of files) {
            Object.assign(components, loadSourceModule(packageInfo, file))
        }
    } else if (componentsJson) {
        // If there were no sourceModules, inspect the manual info instead.
        // TODO: Merge manual info to find more properties.
        const context: ComponentsContext = { packageInfo }
        Object.assign(components, componentsFromExports(exportsObject, componentsJson, context))
    }

    // Pull in design masters that are *not* from the local package.
    if (depth > 0 && designJson) {
        const masters = mastersFromPackage(designJson, packageInfo.name)
        for (const master of masters) {
            const identifier = master.id
            components[identifier] = {
                class: master,
                depth,
                file: "design/document.json",
                identifier,
                name: master.name || "",
                packageIdentifier: packageInfo.name,
                properties: {},
                type: "master",
            }
        }
    }

    return components
}

export function collectPackages(localExports: FramerModuleExports) {
    const packages: PackageMap = {}

    // Queue of packages to visit (breadth-first traversal).
    const queue = [{ exportsObject: localExports, depth: 0 }]
    const seenPackages = new Set<string>()
    while (queue.length > 0) {
        const { exportsObject, depth } = queue.shift()!

        const packageInfo = getPackageInfo(exportsObject, depth)
        if (!packageInfo) continue

        packages[packageInfo.name] = packageInfo
        seenPackages.add(packageInfo.name)

        // Queue up all the dependencies for processing as well.
        for (const dependencyName of Object.keys(packageInfo.dependencies)) {
            if (seenPackages.has(dependencyName)) {
                // We already saw this package once so it doesn't need to be reprocessed.
                // TODO: We should check version and possibly even an integrity hash here.
                continue
            }
            seenPackages.add(dependencyName)
            queue.push({
                exportsObject: packageInfo.dependencies[dependencyName](),
                depth: depth + 1,
            })
        }
    }

    return packages
}

function componentDefinitionFromInfo(
    { name, children, type }: ComponentInfo,
    componentClass: any,
    { identifierPrefix, packageInfo, file }: ComponentsContext
): ComponentDefinition {
    let properties: PropertyControls<any> = {}
    if (typeof componentClass.propertyControls === "object") {
        properties = verifyPropertyControls(componentClass.propertyControls)
    }
    if (children && !properties["children"]) {
        properties["children"] = { title: "Content", type: ControlType.ComponentInstance }
    }

    if (type === undefined || type === "component") {
        componentClass = SetSizeAndPositionChildren(componentClass)
    }

    return {
        class: componentClass,
        defaults: {}, // TODO
        depth: packageInfo.depth,
        file: file || "",
        identifier: prefixIdentifier(packageInfo, name, identifierPrefix),
        name,
        packageIdentifier: packageInfo.name,
        properties,
        type,
    }
}

function componentsFromExports(
    exportsObject: FramerModuleExports | SourceModuleExports,
    componentInfos: ComponentInfo[],
    context: ComponentsContext
): ComponentMap {
    const components: ComponentMap = {}

    for (const componentInfo of componentInfos) {
        const componentClass = exportsObject[componentInfo.name]
        if (!componentClass) {
            warn(`Component '${componentInfo.name}' defined but not found in exports`)
            continue
        }

        const definition = componentDefinitionFromInfo(componentInfo, componentClass, context)
        components[definition.identifier] = definition
    }

    return components
}

function getPackageInfo(exportsObject: FramerModuleExports, depth: number): PackageInfo | null {
    // The module exports should contain a Framer-specific object â€“ extract it.
    const info = exportsObject.__framer__
    if (!info) {
        // No extra info, nothing we can do.
        return null
    }

    const { packageJson, dependencies, sourceModules } = info
    let { name } = packageJson
    if (depth === 0 && !name) {
        name = localPackageFallbackIdentifier
    }

    if (!name) {
        // TODO: Log some more information.
        warn("Failed to identify package")
        return null
    }

    return {
        depth,
        displayName: (packageJson.framer && packageJson.framer.displayName) || name,
        exportsObject,
        name,

        componentsJson: packageJson.framer && packageJson.framer.components,
        designJson: packageJson.design,

        dependencies: dependencies || {},
        sourceModules: sourceModules || {},
    }
}

function loadSourceModule(packageInfo: PackageInfo, file: string): ComponentMap {
    let moduleExports: SourceModuleExports
    try {
        moduleExports = packageInfo.sourceModules[file]() || {}
    } catch (error) {
        moduleExports = { error }
    }

    if (moduleExports.error) {
        const { error } = moduleExports
        warn(`Error in file '${file}':`, error)
        const identifier = prefixIdentifier(packageInfo, file)
        const def = createErrorDefinition(identifier, error, {
            depth: packageInfo.depth,
            packageIdentifier: packageInfo.name,
        })
        return { [identifier]: def }
    }

    if (!moduleExports.__info__) return {}

    return componentsFromExports(moduleExports, moduleExports.__info__, {
        packageInfo,
        file,
        identifierPrefix: `${file}_`,
    })
}

function mastersFromPackage(json: any, packageIdentifier: PackageIdentifier) {
    const masters: any[] = []
    findMasters(json.root, packageIdentifier, masters)
    return masters
}

function prefixIdentifier(packageInfo: PackageInfo, identifier: string, prefix: string = "") {
    // Prefix all non-local identifiers with the package name followed by a slash.
    if (packageInfo.depth > 0) {
        prefix = `${packageInfo.name}/${prefix}`
    }
    return `${prefix}${identifier}`
}
